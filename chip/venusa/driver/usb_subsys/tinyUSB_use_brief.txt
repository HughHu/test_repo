CSK6_tinyUSB使用简介

TinyUSB是用于实现嵌入式系统的开源跨平台USB主机/设备堆栈的第三方库，支持很多设备类，如UAC, HID等等。
目前使用的源码是基于2021年11月底时的版本（0.11.0?）。估计我们主要使用UAC, HID, CDC等几个设备类。

这个版本的UAC是基于UAC2.0实现的，缺少对UAC1.0的支持。在移植时，针对UAC1.0和UAC2.0各类描述符的差异，
我们对audio_device.c/.h进行了一些修改，使它可以同时支持UAC1.0和UAC2.0设备；
但到目前为止（2023.1.16），我们尚未对UAC2.0设备类进行验证。

【2025.1续：】基于ARCS USB 2.0，再次更新相关设备类实现。

———————————————————————————————————————————————————————————————————————————————————————————
关于CSK6_tinyUSB库使用的几点注意事项：

1. tinyUSB的分层————分离库和应用层代码
  tinyUSB库原先设计大概分为这么几层（我们只看设备端，从上到下）：

	应用代码层（位于原examples子文件夹，移植时放在src/usb_subsys文件夹）-> 	
	各个设备类驱动（位于原class子文件夹）+ USBD驱动（位于原src/device子文件夹）->	
	USB Controller驱动（位于原portable子文件夹下，移植时我把CSK6 USB驱动直接放在controller子文件夹下）
	
  原先所有这些代码，不区分“库” 还是“应用层”代码，全部作为一个整体，放在一起编译，形成最后的可执行bin文件。

  移植时，我们将“库”代码（除了应用层代码之外的代码）和“应用层”代码分开来，但是仍然无法完全切割————
  两者需要共享同一份配置文件tusb_config.h（目前位于库代码usb_subsys文件夹）。
  tusb_config.h包含了很多配置————“库”包含 和 “应用层”用到了那些设备类，以及设备类中一些关键参数定义。
  比如UAC设备类中，MIC/SPK的通道数，采样率，每个采样的字节长度，ISO IN/OUT端点最大包长，以及SPK是否有Feedback端点等等。
  这个tusb_config.h文件非常重要，如果改变了其中的配置，“库”代码和“应用层”代码都需要重新编译！！
  也就是说，目前还没有办法做到，同一套“库”代码，支持很多各种不同配置的“应用层”代码。
  【2025.3续：】
  基于listenai_rtos的usb project，所用的bsp/driver（包括tinyUSB库）都是各自编译的，因此可以在各自的project文件夹中
  添加自己特定的tusb_config.h配置文件————只要其Makefile加上如下语句：
  ###############################################################
  #export the absolute path of tusb_config.h
  #CFG_TUSB_CONFIG_H_PATHNAME for usb_subsys compiling
  export CFG_TUSB_CONFIG_H_PATHNAME = $(abspath .)/tusb_config.h
  CFLAGS  += -DCFG_TUSB_CONFIG_FILE=$(CFG_TUSB_CONFIG_H_PATHNAME)
  ###############################################################

2. 回调函数的调用环境————从task改到中断环境
  tinyUSB库原先支持特性“延迟所有中断事件的线程安全，然后在非ISR任务功能中进行处理”——也就是说，
  原tinyUSB对上位机发来的命令（USB收到控制端点中断，从而解析出命令），tinyUSB会自动将命令放入队列中，
  然后在tud_task()函数中，取出命令，调用各种回调函数（最终会调用到应用层提供的回调函数）进行处理。
  这就要求必须在应用层的主消息无限循环中，调用tud_task()函数！
  
  对于像FreeRTOS这种嵌入式OS来说，何时调用tud_task()函数就成为一个难题————
  是在每次任务切换时，调用一次tud_task()呢？还是在专门的一个task中的循环中调用呢？或者软件定时器的处理函数中调用呢？
  前者，需要改到FreeRTOS内核代码中，让FreeRTOS和tinyUSB深度耦合，不合适。
  再说，所有的方案，都会有一定的延迟，通常是任务时间片级的延迟————这对于有一定时间响应要求的命令来说，就是个灾难。
  
  因此，去掉上述特性，不用在tud_task()中处理上位机命令和数据收发，而是在中断环境中直接调用各种回调函数（同样最终会调用到应用层提供的回调函数）；
  那么对于时间要求较高的，直接在回调函数中处理，但前提是快速处理；那么对于时间要求较低的，应用层可以在回调函数中通知task去处理。
  总之，由应用层决定在那种环境中处理上位机命令和数据收发。
  注意：这里面提到一点，几乎绝大多数的应用层需要实现的回调函数，目前移植后的tinyUSB都是在中断环境调用的！！
  
3. RX/TX FIFO————端点收发数据的缓存问题
  TODO:

4. 静态创建设备类实例  
  tinyUSB的各种设备类实例 都是通过宏“静态”声明的，因此开发者需要仔细了解这些创建设备类实例的宏参数，否则可能创建的设备无法被上位机正确识别；
  这与CSK4 USB（Castor USB）用法不同————4系USB设备可用通过调用API，基于少量的配置参数，动态创建出设备类实例。
  简单地说，基于tinyUSB创建设备类实例需要了解更多USB细节。。。
  